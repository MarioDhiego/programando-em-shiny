```{r, echo = FALSE}
knitr::opts_chunk$set(
  fig.align = "center"
)
```

# Golem {#sec-golem}

Neste capítulo, vamos apresentar o framework Golem.

## Motivação

O destino final de aplicativos Shiny costuma ser um ambiente de produção diferente do ambiente de desenvolvimento. Seja um servidor próprio, uma máquina na nuvem ou o [shinyapps.io](https://shinyapps.io/), o nosso app precisa funcionar nesses ambientes, não apenas na nossa máquina.

Uma vez no ambiente de produção, aplicativos Shiny costumam ficar lá por um bom tempo, gerando a necessidade de manutenção períodica e/ou atualizações . 

A depender de como o app foi desenvolvido, essas tarefas podem ficar muito mais trabalhosas. Nesse sentido, seria interessante ter um framework de desenvolvimento que facilitasse a organização e documentação do código e o controle das dependências.

O Golem é um *framework* para desenvolvimento de aplicativos Shiny prontos para serem colocados em produção. As vantagens são:

- padroniza a organização dos scripts e demais arquivos do seu app;

- integra com pacotes que aceleram o desenvolvimento do código;

- motiva e facilita a documentação do código;

- e facilita o compartilhamento e a reutilização de códigos em outros projetos e com outras pessoas.

Na próxima seção, abordaremos como usar o pacote `golem` para obter essas vantagens.

## Como usar?

Antes de mais nada, precisamos instalar o pacote.

```{r, eval = FALSE}
install.packages("golem")
```

Para criar um app dentro do framework Golem, basta rodar o seguinte código:

```{r, eval=FALSE}
golem::create_golem("~/Documents/meuapp")
```

Esse código vai criar uma pasta chamada `meuapp/` dentro de `~/Documents/` (você pode especificar qualquer outra pasta no seu computador). Essa pasta vai conter diversos arquivos que lhe permitirão iniciar o desenvolvimento do seu app dentro do Golem. 

Antes de falarmos dos arquivos dessa pasta, precisamos ter em mente que usar o pacote `golem` diz muito mais respeito a seguir uma filosofia do que a aprender uma ferramenta. Você poderia continuar o desenvolvimento do app dentro desse framework sem utilizar nenhuma outra função do `golem`. O que realmente precisamos fazer é seguir as seguintes premissas:

- um aplicativo Golem é construído como um **pacote R**;

- sempre que conveniente, devemos dividir o nosso app em módulos;

- e devemos documentar funções importantes do aplicativo.

Assim, como já falamos de módulos no capítulo anterior, para darmos mais detalhes sobre a estrutura de arquivos criada e o uso do `golem`, precisamos falar um pouco de pacotes.

## Pacotes

Se você nunca construiu um pacote de R, recomendamos fortemente a leitura do livro [R Packages](https://r-pkgs.org/), em especial os 12 primeiros capítulos. Também recomendamos que treine construindo alguns pacotes simples fora do Shiny/Golem`  antes de continuar (veja os exercícios deste capítulo). Esse passo atrás é importante para que você saiba diferenciar o que é um pacote de R, o que é o Shiny e o que é o Golem.

Dito isso, para aqueles que por imprudência ou falta de tempo continuarão este texto sem  uma base sobre o tema "pacotes", vamos apresentar os pontos necessários para o entendimento do Golem.

### O que é um pacote?

Um pacote de R é uma forma específica de organizar código, seguindo o protocolo descrito pela R Foundation.

> _Pacotes são a unidade fundamental de código R reprodutível._
> 
> — Wickham & Bryan

Um pacote inclue funções em R, documentação sobre como usá-las, testes e dados de exemplo. 

De maneira geral, as funções de um pacote tentam resolver bem um problema em específico. O pacote `dplyr`, por exemplo, possui funções especializadas em manipular bases de dados, já o pacote `ggplot2` possui funções para a construção de gráficos.

### Estrutura básica do pacote

A seguir, apresentaremos a estrutura básica (arquivos e pastas) de qualquer pacote R.

- `DESCRIPTION`: define o nome, descrição, versão, licença, dependências e outras caracaterísticas do pacote. É um arquivo de metadados.

- `LICENSE`: especifica os termos de uso e distribuição do seu pacote.

- `.Rbuildignore`:  lista arquivos que não devem ser incluídos ao compilar o pacote R a partir do código-fonte, isto é, arquivos que são úteis apenas no desenvolvimento e não serão enviados para quem for instalar o pacote.

- `NAMESPACE`: este arquivo declara as funções que o pacote exporta (que ficam disponível quando alguém usa `library()`) e as funções que seu pacote importa de outros pacotes. Não devemos editar este arquivo manualmente. 

- `R/`: pasta onde fica o código R das funções do pacote.

### Criando pacotes

Uma maneira fácil de criarmos a estrutura básica de um pacote é usamos a função `usethis::create_package()`. Você deve passar um caminho como `~/Documents/meupacote` e uma nova pasta chamada `meupacote` será criada dentro da pasta `Documents`. Essa pasta será tanto um projeto do RStudio quanto um pacote, ambos chamados `meupacote`.

> Não adicione acentos, caracteres especiais e espaços no nome do pacote, assim como nos arquivos que você criar dentro dele.

```{r eval=FALSE}
usethis::create_package("~/Documents/meupacote")
```

### A pasta `R/`

Dentro de um pacote, a pasta `R/` só pode ter scripts R com funções. 

Na pasta `R/` guardaremos todas as funções que farão parte do nosso pacote, mesmo que elas sejam apenas funções usadas internamente. As funções colocadas dentro dessa pasta nunca devem ser rodadas diretamente. Se você quiser testá-las, deve fazer isso "carregando as funções", isto é, usando a função `devtools::load_all()`. Isso fará com que todas as funções dentro da pasta `R/` fiquem disponíveis na sua sessão, algo equivalente a fazer `library(meupacote)`, mas com a diferença de também carregar as funções não exportadas.

Podemos usar `usethis::use_r("nome-do-arquivo")` para que um arquivo seja criado antes começarmos a escrever uma função.

### Dependências

Sem os inúmeros pacotes criados pela comunidade, o R provavelmente já estaria no porão da Ciência de Dados. Por isso, é a primeira coisa que escrevemos nos nossos *scripts* quase sempre é `library(algumPacoteLegal)`. Quando estamos construindo um pacote, é comum querermos utilizar dentro dele outros pacotes que não aqueles do R base. Esses pacotes são chamados de **dependências**.

Ao desenvolver um pacote, a função `library()` **nunca deve ser utilizada**^[Imagine se ao usar uma função de um pacote, ele carregasse um novo pacote na sua sessão, possivelmente mascarando funções que você está usando. Isso seria uma péssima prática.], e todas as funções externas devem ter seus pacotes de origem explicitamente referenciados pelo operador `::`. Embora seja chato especificar todos os pacotes, isso traz uma vantagem: as dependências do código estarão sempre atualizadas, pois elas estarão sempre atreladas às próprias funções sendo utilizadas.

Sempre que você utilizar um pacote dentro do pacote que está desenvolvendo, você deve especificá-lo como dependência no arquivo `DESCRIPTION`. Você pode fazer isso facilmente utilizando `usethis::use_package()`. O código abaixo, registra o pacote `dplyr` como dependência do pacote que estamos construindo.

```{r, eval=FALSE}
usethis::use_package("dplyr")
```

### Dados

Se o seu pacote possuir bases de dados, como a `dplyr::starwars`, ou qualquer outro tipo de objeto do R, como `pi` ou `letters`, você deve colocá-los dentro de uma pasta chamada `data/`, na raiz do projeto, com a extensão `.rda`^[Arquivos `.rda` são extremamente estáveis, compactos e podem ser carregados rapidamente pelo R, tornando este formato o principal meio de guardar dados de um pacote.]. Isso pode ser feito facilmente a partir da função `usethis::use_data()`. Por exemplo, ao rodar o código abaixo, vamos criar uma pasta `data/` na raiz do pacote, caso ela não exista ainda, e salvar nela o vetor base `nomes` no arquivo `nomes.rda`.

```{r, eval=FALSE}
nomes <- c("Athos", "Bruna", "Caio")
usethis::use_data(nomes)
```

Fazendo isso, quando alguém carregar esse pacote, o objeto `nomes` ficará disponível para ser utilizado (igual a base `starwars` fica disponível quando carregamos o `dplyr`).

### Documentação de funções

Se quisermos adicionar documentação ao nosso pacote (as instruções que aparecem quando vamos usar uma função ou o documento mostrado quando rodamos `?função()`) precisamos usar um comentário especial: `#'`

```{r eval=FALSE}
#' Título da função
#'
#' Descrição da função
#'
#' @param a primeiro parâmetro
#' @param b segundo parâmetro
#'
#' @return descrição do resultado
#'
#' @export
fun <- function(a, b) {
  a + b
}
```

- O parâmetro `@export` indica que a função ficará disponível quando rodarmos `library(meupacote)`. Não se esqueça de exportar todas (e somente) as funções públicas!

- O RStudio disponibiliza um atalho para criar a estrutura da documentação de uma função. No menu superior, clique em `Code` ->  `Insert Roxygen Skeleton`.

- Para deixar a documentação das suas funções acessível (no help do R), use a função `devtools::document()` (**CTRL + SHIFT + D**).

- Ao executar `devtools::check()`, a documentação já é atualizada e disponibilizada de brinde

## Estrutura de um Golem app

A pasta criada terá a seguinte estrutura:

```{r}
#> ├── DESCRIPTION 
#> ├── NAMESPACE 
#> ├── R 
#> │   ├── app_config.R 
#> │   ├── app_server.R 
#> │   ├── app_ui.R 
#> │   └── run_app.R 
#> ├── dev 
#> │   ├── 01_start.R 
#> │   ├── 02_dev.R 
#> │   ├── 03_deploy.R 
#> │   └── run_dev.R 
#> ├── inst 
#> │   ├── app 
#> │   │   └── www 
#> │   │       └── favicon.ico 
#> │   └── golem-config.yml 
#> └── man 
#>     └── run_app.Rd
```


- Arquivos `DESCRIPTION` e `NAMESPACE`: metadados do pacote.

- `R/app_config.R`: usado para ler o arquivo de configuração do `golem` localizado em `inst/golem-config.yml`.

- `R/app_server.R` e `R/app_ui.R`: arquivos onde vamos desenvolver a UI e o servidor do app.

- `R/run_app.R`: função para configurar e rodar o app.

- `dev/`: scripts do `golem` que podem ser utilizados ao longo do desenvolvimento do app. Eles contêm uma lista de funções úteis que ajudam a configurar diversos aspectos do aplicativo.

- `inst/app/www`: pasta onde adicionaremos os recursos externos do aplicativo (imagens, arquivos CSS, fontes etc).

- `man`: documentação do pacote, a ser gerado pelo R e pelo `roxygen2`.


## Exercícios

Aplique o framework Golem no app disponibilizado [neste link](https://curso-r.github.io/main-dashboards-2/exercicios/03-golem/app.R). Ele utiliza a base de dados Pokemon, que pode ser baixada [clicando aqui](https://curso-r.github.io/main-dashboards-2/dados/pkmn.rds).

- Transforme o shinydashboard em Bs4Dash: construa ao menos a UI do zero.

- Modularize o app (cada página do dashboard deve ser um módulo diferente).

- Refaça os gráficos utilizando alguma biblioteca javascript (plotly, echarts, highcharts etc)

- Faça o deploy do app para o shinyapps.io
