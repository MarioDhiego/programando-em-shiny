```{r, echo = FALSE}
knitr::opts_chunk$set(
  fig.align = "center"
)
```

# Golem {#sec-golem}

Neste capítulo, vamos apresentar o [framework Golem](https://golemverse.org/) para a construção de aplicativos Shiny.

## Motivação

O destino final de aplicativos Shiny costuma ser um ambiente de produção diferente do ambiente de desenvolvimento. Seja um servidor próprio, uma máquina na nuvem ou o [shinyapps.io](https://shinyapps.io/), o nosso app precisa funcionar nesses ambientes, não apenas na nossa máquina.

Uma vez no ambiente de produção, aplicativos Shiny costumam ficar lá por um bom tempo, gerando a necessidade de manutenção períodica e/ou atualizações . 

A depender de como o app foi desenvolvido, essas tarefas podem ficar muito mais trabalhosas. Nesse sentido, seria interessante ter um framework de desenvolvimento que facilitasse a organização e documentação do código e o controle das dependências.

O Golem é um *framework* para desenvolvimento de aplicativos Shiny prontos para serem colocados em produção. As vantagens são:

- padroniza a organização dos scripts e demais arquivos do seu app;

- integra com pacotes que aceleram o desenvolvimento do código;

- motiva e facilita a documentação do código;

- e facilita o compartilhamento e a reutilização de códigos em outros projetos e com outras pessoas.

Na próxima seção, abordaremos como usar o pacote `golem` para obter essas vantagens.

## Como usar?

Antes de mais nada, precisamos instalar o pacote.

```{r, eval = FALSE}
install.packages("golem")
```

Para criar um app dentro do framework Golem, basta rodar o seguinte código:

```{r, eval=FALSE}
golem::create_golem("~/Documents/meuapp")
```

Esse código vai criar uma pasta chamada `meuapp/` dentro de `~/Documents/` (você pode especificar qualquer outra pasta no seu computador). Essa pasta vai conter diversos arquivos que lhe permitirão iniciar o desenvolvimento do seu app dentro do Golem. 

Antes de falarmos dos arquivos dessa pasta, precisamos ter em mente que usar o pacote `golem` diz muito mais respeito a seguir uma filosofia do que a aprender uma ferramenta. Como os próprios autores descrevem, *Golem is an __opinionated__ framework for building production-grade shiny applications*, isto é, para usar o Golem precisamos construir nosso app de um jeito específico, que os autores consideram o melhor. Com relação ao pacote, em si, criada a estrutura inicial a função `golem::create_golem()`, você poderia continuar o desenvolvimento do app dentro desse framework sem utilizar nenhuma outra função do `golem`^[Na prática, poderíamos construir essa estrutura nós mesmos e usar o framework Golem sem usar o pacote `golem`.]. O que realmente importa é seguir as seguintes premissas:

- um aplicativo Golem é construído como um **pacote R**;

- sempre que conveniente, devemos dividir o nosso app em módulos;

- e devemos documentar funções importantes do aplicativo.

Assim, como já falamos de módulos no capítulo anterior, para entender melhor o Golem, precisamos falar um pouco de pacotes.

## Pacotes

Se você nunca construiu um pacote de R, recomendamos fortemente a leitura do livro [R Packages](https://r-pkgs.org/), em especial os 12 primeiros capítulos. Também recomendamos que treine construindo alguns pacotes simples fora do Shiny/Golem`  antes de continuar (veja os exercícios deste capítulo). Esse passo atrás é importante para que você saiba diferenciar o que é um pacote de R, o que é o Shiny e o que é o Golem.

Dito isso, para aqueles que por imprudência ou falta de tempo continuarão este texto sem  uma base sobre o tema "pacotes", vamos apresentar os pontos necessários para o entendimento do Golem.

### O que é um pacote?

Um pacote de R é uma forma específica de organizar código, seguindo o protocolo descrito pela R Foundation.

> _Pacotes são a unidade fundamental de código R reprodutível._
> 
> — Wickham & Bryan

Um pacote inclue funções em R, documentação sobre como usá-las, testes e dados de exemplo. 

De maneira geral, as funções de um pacote tentam resolver bem um problema em específico. O pacote `dplyr`, por exemplo, possui funções especializadas em manipular bases de dados, já o pacote `ggplot2` possui funções para a construção de gráficos.

### Estrutura básica do pacote

A seguir, apresentaremos a estrutura básica (arquivos e pastas) de qualquer pacote R.

- `DESCRIPTION`: define o nome, descrição, versão, licença, dependências e outras caracaterísticas do pacote. É um arquivo de metadados.

- `LICENSE`: especifica os termos de uso e distribuição do seu pacote.

- `.Rbuildignore`:  lista arquivos que não devem ser incluídos ao compilar o pacote R a partir do código-fonte, isto é, arquivos que são úteis apenas no desenvolvimento e não serão enviados para quem for instalar o pacote.

- `NAMESPACE`: este arquivo declara as funções que o pacote exporta (que ficam disponível quando alguém usa `library()`) e as funções que seu pacote importa de outros pacotes. Não devemos editar este arquivo manualmente. 

- `R/`: pasta onde fica o código R das funções do pacote. Essa pasta não deve conter subdiretórios.

### Criando pacotes

Uma maneira fácil de criarmos a estrutura básica de um pacote é usamos a função `usethis::create_package()`. Você deve passar um caminho como `~/Documents/meupacote` e uma nova pasta chamada `meupacote` será criada dentro da pasta `Documents`. Essa pasta será tanto um projeto do RStudio quanto um pacote, ambos chamados `meupacote`.

> Não adicione acentos, caracteres especiais e espaços no nome do pacote, assim como nos arquivos que você criar dentro dele.

```{r eval=FALSE}
usethis::create_package("~/Documents/meupacote")
```

### A pasta `R/`

Dentro de um pacote, a pasta `R/` só pode ter scripts R com funções. 

Na pasta `R/` guardaremos todas as funções que farão parte do nosso pacote, mesmo que elas sejam apenas funções usadas internamente. As funções colocadas dentro dessa pasta nunca devem ser rodadas diretamente. Se você quiser testá-las, deve fazer isso "carregando as funções", isto é, usando a função `devtools::load_all()`. Isso fará com que todas as funções dentro da pasta `R/` fiquem disponíveis na sua sessão, algo equivalente a fazer `library(meupacote)`, mas com a diferença de também carregar as funções não exportadas.

Podemos usar `usethis::use_r("nome-do-arquivo")` para que um arquivo seja criado antes começarmos a escrever uma função.

### Dependências

Sem os inúmeros pacotes criados pela comunidade, o R provavelmente já estaria no porão da Ciência de Dados. Por isso, é a primeira coisa que escrevemos nos nossos *scripts* quase sempre é `library(algumPacoteLegal)`. Quando estamos construindo um pacote, é comum querermos utilizar dentro dele outros pacotes que não aqueles do R base. Esses pacotes são chamados de **dependências**.

Ao desenvolver um pacote, a função `library()` **nunca deve ser utilizada**^[Imagine se ao usar uma função de um pacote, ele carregasse um novo pacote na sua sessão, possivelmente mascarando funções que você está usando. Isso seria uma péssima prática.], e todas as funções externas devem ter seus pacotes de origem explicitamente referenciados pelo operador `::`. Embora seja chato especificar todos os pacotes, isso traz uma vantagem: as dependências do código estarão sempre atualizadas, pois elas estarão sempre atreladas às próprias funções sendo utilizadas.

Sempre que você utilizar um pacote dentro do pacote que está desenvolvendo, você deve especificá-lo como dependência no arquivo `DESCRIPTION`. Você pode fazer isso facilmente utilizando `usethis::use_package()`. O código abaixo, registra o pacote `dplyr` como dependência do pacote que estamos construindo.

```{r, eval=FALSE}
usethis::use_package("dplyr")
```

### Dados

Se o seu pacote possuir bases de dados, como a `dplyr::starwars`, ou qualquer outro tipo de objeto do R, como `pi` ou `letters`, você deve colocá-los dentro de uma pasta chamada `data/`, na raiz do projeto, com a extensão `.rda`^[Arquivos `.rda` são extremamente estáveis, compactos e podem ser carregados rapidamente pelo R, tornando este formato o principal meio de guardar dados de um pacote.]. Isso pode ser feito facilmente a partir da função `usethis::use_data()`. Por exemplo, ao rodar o código abaixo, vamos criar uma pasta `data/` na raiz do pacote, caso ela não exista ainda, e salvar nela o vetor base `nomes` no arquivo `nomes.rda`.

```{r, eval=FALSE}
nomes <- c("Athos", "Bruna", "Caio")
usethis::use_data(nomes)
```

Fazendo isso, quando alguém carregar esse pacote, o objeto `nomes` ficará disponível para ser utilizado (igual a base `starwars` fica disponível quando carregamos o `dplyr`).

### Documentação de funções

Para documentar as funções do seu pacote (gerar aquele documento mostrado quando rodamos `?mean`, por exemplo), escrevemos comentários antes da definição da função, nos scripts da pasta `R/`. Fazemos isso usando um tipo de comentários especial, o `#'`, e marcadores que indicam qual parte da documentação estamos escrevendo. A estrutura dos comentários deve ser a seguinte:

```{r eval=FALSE}
#' Título da função
#'
#' Descrição da função
#'
#' @param a primeiro parâmetro
#' @param b segundo parâmetro
#'
#' @return descrição do resultado
#'
#' @export
fun <- function(a, b) {
  a + b
}
```

O parâmetro `@export` indica que a função ficará disponível quando rodarmos `library(meupacote)`. Se você não quer que a função fique disponível, basta não colocar esse marcador. 

Após escrever a documentação das suas funções dessa maneira, você deve rodar `devtools::document()` para que ela seja compilada e fique disponível no seu pacote (acessível pelo *Help* do R). Isso é feito por trás das cortinas pelo pacote `roxygen2`.

**Dica**: o RStudio disponibiliza um atalho para criar a estrutura da documentação de uma função. No menu superior, clique em `Code` ->  `Insert Roxygen Skeleton`.

Para saber mais sobre documentação de pacotes, leia [este capítulo do R Packages](https://r-pkgs.org/man.html).

### Instalando e compartilhando o seu pacote

Para verificar se você não feriu nenhuma regra de desenvolvimento de pacotes R, você pode usar a função `devtools::check()`. Essa função devolverá uma relatório com possíveis problemas que o seu pacote pode ter, como erros de sintaxe, arquivos com extensões não permitidos, dependências não declaradas ou erros de documentação.

Para instalar o seu pacote localmente durante o desenvolvimento, rode a função `devtools::install()`. Isso é equivalente a ter o pacote instalado via `install.packages()`.

O jeito mais fácil de disponibilizar o seu pacote na internet é subi-lo para um repositório público no Github. Dessa maneira, qualquer pessoa pode instalá-lo com a função `remotes::install_github()`.

Para subir um pacote para o CRAN, o processo é (bem) mais burocrático. Se você quiser saber mais, leia [este capítulo do R Packages](https://r-pkgs.org/release.html).

## Estrutura de um Golem app

Uma pasta criada pela função `golem::create_golem()` terá a seguinte estrutura:

```{r}
#> ├── DESCRIPTION 
#> ├── NAMESPACE 
#> ├── R 
#> │   ├── app_config.R 
#> │   ├── app_server.R 
#> │   ├── app_ui.R 
#> │   └── run_app.R 
#> ├── dev 
#> │   ├── 01_start.R 
#> │   ├── 02_dev.R 
#> │   ├── 03_deploy.R 
#> │   └── run_dev.R 
#> ├── inst 
#> │   ├── app 
#> │   │   └── www 
#> │   │       └── favicon.ico 
#> │   └── golem-config.yml 
#> └── man 
#>     └── run_app.Rd
```

Veja que ela possui, entre outras coisas, a estrutura básica de um pacote. Vamos descrever cada arquivo mais detalhadamente e discutir a importância dele no contexto do desenvolvimento de um Shiny app:

- O arquivo `DESCRIPTION`: guarda os metadados do pacote. No desenvolvimento de um aplicativo Shiny, ele vai guardar o nome do aplicativo, o que ele faz, as dependências dele, a versão (importante em projetos em produção que recebem atualizações periódicas) e quem contatar quando alguma coisa der errada.

- O arquivo `NAMESPACE`: guarda metadados do pacote. Com esse arquivo, podemos carregar apenas funções específicas de um pacote dentro do nosso app^[Isso é feito automaticamente pelo `roxygen2` a partir da documentação das funções. Não edite esse arquivo na mão.]. O Golem faz isso com funções do `shiny` e do próprio `golem` para não precisarmos colocar `shiny::` no início de cada função.

- A pasta `R/`: guarda as funções do pacote. Como o app será feito dentro de um pacote R, todo o seu código será escrito em funções nessa pasta. O Golem já cria os arquivos para construirmos a UI e o servidor. Os scripts contendo os módulos do aplicativo também devem ser colocados nessa pasta, assim como scripts com funções úteis utilizadas em vários lugares do app.

- O arquivo `R/app_config.R`: usado especificar alguns mecanismos do Golem, como ler o arquivo de configuração localizado em `inst/golem-config.yml`.

- O arquivo `R/app_server.R`: script com a função `app_server()`, onde você vai desenvolver o servidor do seu aplicativo.

- O arquivo `R/app_ui.R`: script com a função `app_ui()`, onde você vai desenvolver a UI do seu aplicativo, e a função `golem_add_external_resources()`, utilizada para dizer ao Shiny que a pasta `inst/app/www` será utilizada como uma fonte de recursos externos, acessada pelo caminho `www/nome_do_arquivo`^[Isto é, você não precisa incluir `inst/app/` no caminho do arquivo. Por exemplo, se você quiser colocar a imagem `inst/app/www/imagem.png` no seu app, basta usar o caminho `www/imagem.png`.]. Além disso, o Golem inclui no HTML do seu app todo arquivo CSS e JS que você coloca nessa pasta, então não precisamos fazer isso manualmente.

- O arquivo `R/run_app.R`: script que contém a função `run_app()`, utilizada para rodar o app. Ela chama a função `shiny::shinyApp()`, que inicia o app localmente. A funcão `shiny::shinyApp()` está dentro da função `golem::with_golem_options()`, que recebe parâmetros passados para a `run_app()`. Esses parâmetros podem ser recuperados dentro do app com a função `golem::get_golem_options()`, deixando a parametrização de um aplicativo Shiny muito mais simples^[Podemos criar versões diferentes do app que serão executadas a depender dos parâmetros passados na função `run_app()`.].

- `dev/`: pasta com scripts do `golem` que podem ser utilizados ao longo do desenvolvimento do app. Eles contêm uma lista de funções úteis que ajudam a configurar diversos aspectos do aplicativo.

- `inst/app/www`: pasta onde adicionaremos os recursos externos do aplicativo (imagens, arquivos CSS, fontes etc) que serão compartilhados com o navegador de quem estiver usando o app.

- `man`: documentação do pacote, a ser gerado pelo R e pelo `roxygen2`.

## Rodando o app

Quando quisermos rodar o app durante o desenvolvimento, utilizamos a função `devtools::load_all()` para carregar a versão mais recente de todas as funções do pacote e a função `run_app()` para efetivamente rodar o aplicativo (ela chama a função `shiny::shinyApp()`, com as funções `app_ui()` e `app_server()` como argumentos).

## Principais funções

Além da função `golem::create_golem()` que utilizamos para criar o nosso projeto com a estrutura do framework Golem, o pacote `golem` possui diversas funções úteis para usarmos durante o desenvolvimento do pacote. Vamos listar a seguir algumas delas:

- `golem::set_golem_name()`: usada para mudar o nome do seu aplicativo. A mudança precisa ser feita tanto no arquivo `DESCRIPTION` quanto dentro da função `app_sys()` contida no arquivo `R/app_config.R` e essa função realiza essa tarefa.

- `golem::add_module()`: cria um arquivo na pasta `R/` com o template de um módulo do Shiny. O nome do módulo (utilizado também no nome do arquivo) é passado pelo argumento `name`.

- `golem::add_css_file()`: cria um arquivo vazio com extensão `.css` dentro da pasta `inst/app/www` do app. O nome desse arquivo pode ser passado pelo argumento `name`.

## Deploy

## Exercícios

Aplique o framework Golem no app disponibilizado [neste link](https://curso-r.github.io/main-dashboards-2/exercicios/03-golem/app.R). Ele utiliza a base de dados Pokemon, que pode ser baixada [clicando aqui](https://curso-r.github.io/main-dashboards-2/dados/pkmn.rds).

- Transforme o shinydashboard em Bs4Dash: construa ao menos a UI do zero.

- Modularize o app (cada página do dashboard deve ser um módulo diferente).

- Refaça os gráficos utilizando alguma biblioteca javascript (plotly, echarts, highcharts etc)

- Faça o deploy do app para o shinyapps.io
